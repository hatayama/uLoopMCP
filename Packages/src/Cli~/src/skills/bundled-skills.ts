/**
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: scripts/generate-bundled-skills.ts
 *
 * This file is automatically generated from:
 *   - Editor/Api/McpTools/<ToolFolder>/SKILL.md
 *   - Editor/Api/McpTools/<ToolFolder>/examples/*.md (additional files)
 *   - skill-definitions/cli-only/<SkillFolder>/SKILL.md
 *
 * To add a new skill, create a SKILL.md file in the appropriate location.
 * To exclude a skill from bundling, add `internal: true` to its frontmatter.
 */

import captureWindowSkill from '../../../Editor/Api/McpTools/CaptureWindow/SKILL.md';
import clearConsoleSkill from '../../../Editor/Api/McpTools/ClearConsole/SKILL.md';
import compileSkill from '../../../Editor/Api/McpTools/Compile/SKILL.md';
import controlPlayModeSkill from '../../../Editor/Api/McpTools/ControlPlayMode/SKILL.md';
import executeDynamicCodeSkill from '../../../Editor/Api/McpTools/ExecuteDynamicCode/SKILL.md';
import executeMenuItemSkill from '../../../Editor/Api/McpTools/ExecuteMenuItem/SKILL.md';
import findGameObjectsSkill from '../../../Editor/Api/McpTools/FindGameObjects/SKILL.md';
import focusWindowSkill from '../../../Editor/Api/McpTools/FocusUnityWindow/SKILL.md';
import getHierarchySkill from '../../../Editor/Api/McpTools/GetHierarchy/SKILL.md';
import getLogsSkill from '../../../Editor/Api/McpTools/GetLogs/SKILL.md';
import getMenuItemsSkill from '../../../Editor/Api/McpTools/GetMenuItems/SKILL.md';
import getProviderDetailsSkill from '../../../Editor/Api/McpTools/UnitySearchProviderDetails/SKILL.md';
import runTestsSkill from '../../../Editor/Api/McpTools/RunTests/SKILL.md';
import unitySearchSkill from '../../../Editor/Api/McpTools/UnitySearch/SKILL.md';

export interface BundledSkill {
  name: string;
  dirName: string;
  content: string;
  additionalFiles?: Record<string, string>;
}

export const BUNDLED_SKILLS: BundledSkill[] = [
  {
    name: 'uloop-capture-window',
    dirName: 'uloop-capture-window',
    content: captureWindowSkill,
  },
  {
    name: 'uloop-clear-console',
    dirName: 'uloop-clear-console',
    content: clearConsoleSkill,
  },
  {
    name: 'uloop-compile',
    dirName: 'uloop-compile',
    content: compileSkill,
  },
  {
    name: 'uloop-control-play-mode',
    dirName: 'uloop-control-play-mode',
    content: controlPlayModeSkill,
  },
  {
    name: 'uloop-execute-dynamic-code',
    dirName: 'uloop-execute-dynamic-code',
    content: executeDynamicCodeSkill,
    additionalFiles: {
      'examples/asset-operations.md': `# Asset Operations

Code examples for AssetDatabase operations using \`execute-dynamic-code\`.

## Find Assets by Type

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

string[] prefabGuids = AssetDatabase.FindAssets("t:Prefab");
List<string> paths = new List<string>();

foreach (string guid in prefabGuids)
{
    paths.Add(AssetDatabase.GUIDToAssetPath(guid));
}
return $"Found {paths.Count} prefabs";
\`\`\`

## Find Assets by Name

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

string searchName = "Player";
string[] guids = AssetDatabase.FindAssets(searchName);
List<string> paths = new List<string>();

foreach (string guid in guids)
{
    paths.Add(AssetDatabase.GUIDToAssetPath(guid));
}
return $"Found {paths.Count} assets matching '{searchName}'";
\`\`\`

## Find Assets in Folder

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

string folder = "Assets/Prefabs";
string[] guids = AssetDatabase.FindAssets("t:Prefab", new[] { folder });
List<string> paths = new List<string>();

foreach (string guid in guids)
{
    paths.Add(AssetDatabase.GUIDToAssetPath(guid));
}
return $"Found {paths.Count} prefabs in {folder}";
\`\`\`

## Duplicate Asset

\`\`\`csharp
using UnityEditor;

string sourcePath = "Assets/Materials/MyMaterial.mat";
string destPath = "Assets/Materials/MyMaterial_Backup.mat";

bool success = AssetDatabase.CopyAsset(sourcePath, destPath);
return success ? $"Copied to {destPath}" : "Copy failed";
\`\`\`

## Move Asset

\`\`\`csharp
using UnityEditor;

string sourcePath = "Assets/OldFolder/MyAsset.asset";
string destPath = "Assets/NewFolder/MyAsset.asset";

string error = AssetDatabase.MoveAsset(sourcePath, destPath);
return string.IsNullOrEmpty(error) ? $"Moved to {destPath}" : $"Error: {error}";
\`\`\`

## Rename Asset

\`\`\`csharp
using UnityEditor;

string assetPath = "Assets/Materials/OldName.mat";
string newName = "NewName";

string error = AssetDatabase.RenameAsset(assetPath, newName);
return string.IsNullOrEmpty(error) ? $"Renamed to {newName}" : $"Error: {error}";
\`\`\`

## Rename Asset (Undo-supported)

\`\`\`csharp
using UnityEditor;

// ObjectNames.SetNameSmart() supports Undo (AssetDatabase.RenameAsset() does NOT)
Object selected = Selection.activeObject;
if (selected == null)
{
    return "No asset selected";
}

string oldName = selected.name;
ObjectNames.SetNameSmart(selected, "NewName");
AssetDatabase.SaveAssets();
return $"Renamed {oldName} to {selected.name}";
\`\`\`

## Get Asset Path from Object

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No object selected";
}

string path = AssetDatabase.GetAssetPath(selected);
if (string.IsNullOrEmpty(path))
{
    return "Selected object is not an asset (scene object)";
}
return $"Asset path: {path}";
\`\`\`

## Load Asset at Path

\`\`\`csharp
using UnityEditor;

string path = "Assets/Prefabs/Player.prefab";
GameObject asset = AssetDatabase.LoadAssetAtPath<GameObject>(path);

if (asset == null)
{
    return $"Asset not found at {path}";
}
return $"Loaded: {asset.name}";
\`\`\`

## Get All Assets of Type

\`\`\`csharp
using UnityEditor;

string[] scriptGuids = AssetDatabase.FindAssets("t:MonoScript");
int count = 0;

foreach (string guid in scriptGuids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    if (path.StartsWith("Assets/"))
    {
        count++;
    }
}
return $"Found {count} scripts in Assets folder";
\`\`\`

## Check if Asset Exists

\`\`\`csharp
using UnityEditor;

string path = "Assets/Prefabs/Player.prefab";
string guid = AssetDatabase.AssetPathToGUID(path);

bool exists = !string.IsNullOrEmpty(guid);
return exists ? $"Asset exists: {path}" : $"Asset not found: {path}";
\`\`\`

## Get Asset Dependencies

\`\`\`csharp
using UnityEditor;

string assetPath = "Assets/Prefabs/Player.prefab";
string[] dependencies = AssetDatabase.GetDependencies(assetPath, true);

return $"Asset has {dependencies.Length} dependencies";
\`\`\`

## Refresh AssetDatabase

\`\`\`csharp
using UnityEditor;

AssetDatabase.Refresh();
return "AssetDatabase refreshed";
\`\`\`
`,
      'examples/batch-operations.md': `# Batch Operations

Code examples for batch processing using \`execute-dynamic-code\`.

## Batch Modify Selected Objects

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Modify");

foreach (GameObject obj in selected)
{
    Undo.RecordObject(obj.transform, "");
    obj.transform.localScale = Vector3.one * 2;
}

Undo.CollapseUndoOperations(undoGroup);
return $"Scaled {selected.Length} objects (Single undo step)";
\`\`\`

## Edit Multiple Objects with SerializedObject

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

List<Transform> transforms = new List<Transform>();
foreach (GameObject obj in selected)
{
    transforms.Add(obj.transform);
}

SerializedObject serializedObj = new SerializedObject(transforms.ToArray());
SerializedProperty positionProp = serializedObj.FindProperty("m_LocalPosition");
positionProp.vector3Value = Vector3.zero;
serializedObj.ApplyModifiedProperties();

return $"Reset position of {selected.Length} objects";
\`\`\`

## Batch Add Component

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Add Rigidbody");

int addedCount = 0;
foreach (GameObject obj in selected)
{
    if (obj.GetComponent<Rigidbody>() == null)
    {
        Undo.AddComponent<Rigidbody>(obj);
        addedCount++;
    }
}

Undo.CollapseUndoOperations(undoGroup);
return $"Added Rigidbody to {addedCount} objects";
\`\`\`

## Batch Process Assets with StartAssetEditing

\`\`\`csharp
using UnityEditor;

string[] guids = AssetDatabase.FindAssets("t:Material", new[] { "Assets/Materials" });
if (guids.Length == 0)
{
    return "No materials found";
}

AssetDatabase.StartAssetEditing();

int modified = 0;
foreach (string guid in guids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    Material mat = AssetDatabase.LoadAssetAtPath<Material>(path);
    if (mat != null)
    {
        mat.color = Color.white;
        EditorUtility.SetDirty(mat);
        modified++;
    }
}

AssetDatabase.StopAssetEditing();
AssetDatabase.SaveAssets();

return $"Reset color of {modified} materials";
\`\`\`

## Batch Rename GameObjects

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Rename");

for (int i = 0; i < selected.Length; i++)
{
    Undo.RecordObject(selected[i], "");
    selected[i].name = $"Item_{i:D3}";
}

Undo.CollapseUndoOperations(undoGroup);
return $"Renamed {selected.Length} objects";
\`\`\`

## Batch Set Layer

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

int layer = LayerMask.NameToLayer("Default");

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Set Layer");

foreach (GameObject obj in selected)
{
    Undo.RecordObject(obj, "");
    obj.layer = layer;
}

Undo.CollapseUndoOperations(undoGroup);
return $"Set layer of {selected.Length} objects to Default";
\`\`\`

## Batch Set Tag

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Set Tag");

foreach (GameObject obj in selected)
{
    Undo.RecordObject(obj, "");
    obj.tag = "Enemy";
}

Undo.CollapseUndoOperations(undoGroup);
return $"Tagged {selected.Length} objects as Enemy";
\`\`\`

## Batch Modify ScriptableObjects

\`\`\`csharp
using UnityEditor;

string[] guids = AssetDatabase.FindAssets("t:ScriptableObject", new[] { "Assets/Data" });
if (guids.Length == 0)
{
    return "No ScriptableObjects found";
}

int modified = 0;
foreach (string guid in guids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    ScriptableObject so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);
    if (so == null) continue;

    SerializedObject serializedObj = new SerializedObject(so);
    SerializedProperty prop = serializedObj.FindProperty("isEnabled");
    if (prop != null)
    {
        prop.boolValue = true;
        serializedObj.ApplyModifiedProperties();
        EditorUtility.SetDirty(so);
        modified++;
    }
}

AssetDatabase.SaveAssets();
return $"Enabled {modified} ScriptableObjects";
\`\`\`

## Batch Remove Component

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Remove Rigidbody");

int removedCount = 0;
foreach (GameObject obj in selected)
{
    Rigidbody rb = obj.GetComponent<Rigidbody>();
    if (rb != null)
    {
        Undo.DestroyObjectImmediate(rb);
        removedCount++;
    }
}

Undo.CollapseUndoOperations(undoGroup);
return $"Removed Rigidbody from {removedCount} objects";
\`\`\`

## Batch Set Static Flags

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Set Static");

foreach (GameObject obj in selected)
{
    Undo.RecordObject(obj, "");
    GameObjectUtility.SetStaticEditorFlags(obj, StaticEditorFlags.BatchingStatic | StaticEditorFlags.OccludeeStatic);
}

Undo.CollapseUndoOperations(undoGroup);
return $"Set static flags on {selected.Length} objects";
\`\`\`

## Batch Process with Progress Bar

\`\`\`csharp
using UnityEditor;

string[] guids = AssetDatabase.FindAssets("t:Texture2D");
if (guids.Length == 0)
{
    return "No textures found";
}

int processed = 0;
foreach (string guid in guids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    TextureImporter importer = AssetImporter.GetAtPath(path) as TextureImporter;
    if (importer != null && importer.maxTextureSize > 1024)
    {
        importer.maxTextureSize = 1024;
        importer.SaveAndReimport();
        processed++;
    }

    if (processed % 10 == 0)
    {
        EditorUtility.DisplayProgressBar("Processing Textures", path, (float)processed / guids.Length);
    }
}

EditorUtility.ClearProgressBar();
return $"Resized {processed} textures to max 1024";
\`\`\`

## Batch Align Objects

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length < 2)
{
    return "Select at least 2 objects";
}

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Align Objects");

float startX = selected[0].transform.position.x;
float spacing = 2f;

for (int i = 0; i < selected.Length; i++)
{
    Undo.RecordObject(selected[i].transform, "");
    Vector3 pos = selected[i].transform.position;
    pos.x = startX + (i * spacing);
    selected[i].transform.position = pos;
}

Undo.CollapseUndoOperations(undoGroup);
return $"Aligned {selected.Length} objects with {spacing}m spacing";
\`\`\`

## Batch Rename Assets (Undo-supported)

\`\`\`csharp
using UnityEditor;

// ObjectNames.SetNameSmart() supports Undo (AssetDatabase.RenameAsset() does NOT)
Object[] selected = Selection.objects;
if (selected.Length == 0)
{
    return "No assets selected";
}

for (int i = 0; i < selected.Length; i++)
{
    string newName = $"{i:D3}_{selected[i].name}";
    ObjectNames.SetNameSmart(selected[i], newName);
}

AssetDatabase.SaveAssets();
return $"Renamed {selected.Length} assets";
\`\`\`

## Batch Replace Material

\`\`\`csharp
using UnityEditor;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

string materialPath = "Assets/Materials/NewMaterial.mat";
Material newMat = AssetDatabase.LoadAssetAtPath<Material>(materialPath);
if (newMat == null)
{
    return $"Material not found at {materialPath}";
}

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Replace Material");

int replaced = 0;
foreach (GameObject obj in selected)
{
    MeshRenderer renderer = obj.GetComponent<MeshRenderer>();
    if (renderer != null)
    {
        Undo.RecordObject(renderer, "");
        renderer.sharedMaterial = newMat;
        replaced++;
    }
}

Undo.CollapseUndoOperations(undoGroup);
return $"Replaced material on {replaced} objects";
\`\`\`

`,
      'examples/cleanup-operations.md': `# Cleanup Operations

Code examples for project cleanup operations using \`execute-dynamic-code\`.

## Detect Missing Scripts on GameObject

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

int missingCount = GameObjectUtility.GetMonoBehavioursWithMissingScriptCount(selected);
return $"{selected.name} has {missingCount} missing script(s)";
\`\`\`

## Remove Missing Scripts from GameObject

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

int removedCount = GameObjectUtility.RemoveMonoBehavioursWithMissingScript(selected);
return $"Removed {removedCount} missing script(s) from {selected.name}";
\`\`\`

## Scan Scene for Missing Scripts

\`\`\`csharp
using UnityEditor;

GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);
List<string> objectsWithMissing = new List<string>();

foreach (GameObject obj in allObjects)
{
    int count = GameObjectUtility.GetMonoBehavioursWithMissingScriptCount(obj);
    if (count > 0)
    {
        objectsWithMissing.Add($"{obj.name} ({count})");
    }
}

if (objectsWithMissing.Count == 0)
{
    return "No missing scripts found in scene";
}

return $"Objects with missing scripts: {string.Join(", ", objectsWithMissing)}";
\`\`\`

## Remove All Missing Scripts from Scene

\`\`\`csharp
using UnityEditor;

GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);
int totalRemoved = 0;

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Remove All Missing Scripts");

foreach (GameObject obj in allObjects)
{
    int removed = GameObjectUtility.RemoveMonoBehavioursWithMissingScript(obj);
    totalRemoved += removed;
}

Undo.CollapseUndoOperations(undoGroup);
return $"Removed {totalRemoved} missing scripts from scene";
\`\`\`

## Detect Missing References in Component

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

List<string> missingRefs = new List<string>();

Component[] components = selected.GetComponents<Component>();
foreach (Component comp in components)
{
    if (comp == null) continue;

    SerializedObject so = new SerializedObject(comp);
    SerializedProperty prop = so.GetIterator();

    while (prop.NextVisible(true))
    {
        if (prop.propertyType == SerializedPropertyType.ObjectReference)
        {
            if (prop.objectReferenceValue == null && prop.objectReferenceInstanceIDValue != 0)
            {
                missingRefs.Add($"{comp.GetType().Name}.{prop.name}");
            }
        }
    }
}

if (missingRefs.Count == 0)
{
    return "No missing references found";
}

return $"Missing references: {string.Join(", ", missingRefs)}";
\`\`\`

## Scan Scene for Missing References

\`\`\`csharp
using UnityEditor;

GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);
List<string> results = new List<string>();

foreach (GameObject obj in allObjects)
{
    Component[] components = obj.GetComponents<Component>();
    foreach (Component comp in components)
    {
        if (comp == null) continue;

        SerializedObject so = new SerializedObject(comp);
        SerializedProperty prop = so.GetIterator();

        while (prop.NextVisible(true))
        {
            if (prop.propertyType == SerializedPropertyType.ObjectReference)
            {
                if (prop.objectReferenceValue == null && prop.objectReferenceInstanceIDValue != 0)
                {
                    results.Add($"{obj.name}/{comp.GetType().Name}.{prop.name}");
                }
            }
        }
    }
}

if (results.Count == 0)
{
    return "No missing references found in scene";
}

return $"Missing references ({results.Count}): {string.Join(", ", results.Take(10))}...";
\`\`\`

## Find Unused Materials in Project

\`\`\`csharp
using UnityEditor;

string[] materialGuids = AssetDatabase.FindAssets("t:Material");
HashSet<string> usedMaterials = new HashSet<string>();

string[] prefabGuids = AssetDatabase.FindAssets("t:Prefab");
foreach (string guid in prefabGuids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    string[] deps = AssetDatabase.GetDependencies(path, true);
    foreach (string dep in deps)
    {
        if (dep.EndsWith(".mat"))
        {
            usedMaterials.Add(dep);
        }
    }
}

List<string> unusedMaterials = new List<string>();
foreach (string guid in materialGuids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    if (!usedMaterials.Contains(path))
    {
        unusedMaterials.Add(path);
    }
}

return $"Found {unusedMaterials.Count} potentially unused materials";
\`\`\`

## Find Empty GameObjects

\`\`\`csharp
using UnityEditor;

GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);
List<string> emptyObjects = new List<string>();

foreach (GameObject obj in allObjects)
{
    Component[] components = obj.GetComponents<Component>();
    if (components.Length == 1 && obj.transform.childCount == 0)
    {
        emptyObjects.Add(obj.name);
    }
}

if (emptyObjects.Count == 0)
{
    return "No empty GameObjects found";
}

return $"Empty objects ({emptyObjects.Count}): {string.Join(", ", emptyObjects.Take(20))}";
\`\`\`

## Find Duplicate Names in Hierarchy

\`\`\`csharp
using UnityEditor;

GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);
Dictionary<string, int> nameCounts = new Dictionary<string, int>();

foreach (GameObject obj in allObjects)
{
    if (nameCounts.ContainsKey(obj.name))
    {
        nameCounts[obj.name]++;
    }
    else
    {
        nameCounts[obj.name] = 1;
    }
}

List<string> duplicates = new List<string>();
foreach (KeyValuePair<string, int> kvp in nameCounts)
{
    if (kvp.Value > 1)
    {
        duplicates.Add($"{kvp.Key} ({kvp.Value})");
    }
}

if (duplicates.Count == 0)
{
    return "No duplicate names found";
}

return $"Duplicate names: {string.Join(", ", duplicates.Take(15))}";
\`\`\`

## Check for Broken Prefab Instances

\`\`\`csharp
using UnityEditor;

GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);
List<string> brokenPrefabs = new List<string>();

foreach (GameObject obj in allObjects)
{
    if (PrefabUtility.IsPartOfPrefabInstance(obj))
    {
        GameObject prefabAsset = PrefabUtility.GetCorrespondingObjectFromSource(obj);
        if (prefabAsset == null)
        {
            brokenPrefabs.Add(obj.name);
        }
    }
}

if (brokenPrefabs.Count == 0)
{
    return "No broken prefab instances found";
}

return $"Broken prefab instances: {string.Join(", ", brokenPrefabs)}";
\`\`\`

## Find Objects with Negative Scale

\`\`\`csharp
using UnityEditor;

GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);
List<string> negativeScale = new List<string>();

foreach (GameObject obj in allObjects)
{
    Vector3 scale = obj.transform.localScale;
    if (scale.x < 0 || scale.y < 0 || scale.z < 0)
    {
        negativeScale.Add($"{obj.name} ({scale})");
    }
}

if (negativeScale.Count == 0)
{
    return "No objects with negative scale found";
}

return $"Negative scale objects: {string.Join(", ", negativeScale.Take(10))}";
\`\`\`

## Remove Empty Parent GameObjects

\`\`\`csharp
using UnityEditor;

GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Remove Empty Parents");

int removedCount = 0;
foreach (GameObject obj in allObjects)
{
    if (obj == null) continue;

    Component[] components = obj.GetComponents<Component>();
    if (components.Length == 1 && obj.transform.childCount == 0)
    {
        Undo.DestroyObjectImmediate(obj);
        removedCount++;
    }
}

Undo.CollapseUndoOperations(undoGroup);
return $"Removed {removedCount} empty GameObjects";
\`\`\`

## Find Large Meshes

\`\`\`csharp
using UnityEditor;

string[] meshGuids = AssetDatabase.FindAssets("t:Mesh");
List<string> largeMeshes = new List<string>();
int threshold = 10000;

foreach (string guid in meshGuids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    Mesh mesh = AssetDatabase.LoadAssetAtPath<Mesh>(path);
    if (mesh != null && mesh.vertexCount > threshold)
    {
        largeMeshes.Add($"{path} ({mesh.vertexCount} verts)");
    }
}

if (largeMeshes.Count == 0)
{
    return $"No meshes with more than {threshold} vertices found";
}

return $"Large meshes: {string.Join(", ", largeMeshes.Take(10))}";
\`\`\`

## Validate Asset References

\`\`\`csharp
using UnityEditor;

string[] guids = AssetDatabase.FindAssets("t:ScriptableObject", new[] { "Assets/Data" });
List<string> invalidRefs = new List<string>();

foreach (string guid in guids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    ScriptableObject so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);
    if (so == null) continue;

    SerializedObject serializedObj = new SerializedObject(so);
    SerializedProperty prop = serializedObj.GetIterator();

    while (prop.NextVisible(true))
    {
        if (prop.propertyType == SerializedPropertyType.ObjectReference)
        {
            if (prop.objectReferenceValue == null && prop.objectReferenceInstanceIDValue != 0)
            {
                invalidRefs.Add($"{path}: {prop.name}");
            }
        }
    }
}

if (invalidRefs.Count == 0)
{
    return "All asset references are valid";
}

return $"Invalid references ({invalidRefs.Count}): {string.Join(", ", invalidRefs.Take(10))}";
\`\`\`

`,
      'examples/material-operations.md': `# Material Operations

Code examples for Material operations using \`execute-dynamic-code\`.

## Create a New Material

\`\`\`csharp
using UnityEditor;

Shader shader = Shader.Find("Standard");
Material mat = new Material(shader);
mat.name = "MyMaterial";
string path = "Assets/Materials/MyMaterial.mat";
AssetDatabase.CreateAsset(mat, path);
AssetDatabase.SaveAssets();
return $"Material created at {path}";
\`\`\`

## Set Material Color

\`\`\`csharp
using UnityEditor;

string matPath = "Assets/Materials/MyMaterial.mat";
Material mat = AssetDatabase.LoadAssetAtPath<Material>(matPath);
mat.SetColor("_Color", new Color(1f, 0.5f, 0f, 1f));
EditorUtility.SetDirty(mat);
AssetDatabase.SaveAssets();
return "Material color set to orange";
\`\`\`

## Set Material Properties (Float, Vector)

\`\`\`csharp
using UnityEditor;

string matPath = "Assets/Materials/MyMaterial.mat";
Material mat = AssetDatabase.LoadAssetAtPath<Material>(matPath);

mat.SetFloat("_Metallic", 0.8f);
mat.SetFloat("_Glossiness", 0.6f);
mat.SetVector("_EmissionColor", new Vector4(1, 1, 0, 1));

EditorUtility.SetDirty(mat);
AssetDatabase.SaveAssets();
return "Material properties updated";
\`\`\`

## Assign Texture to Material

\`\`\`csharp
using UnityEditor;

string matPath = "Assets/Materials/MyMaterial.mat";
string texPath = "Assets/Textures/MyTexture.png";

Material mat = AssetDatabase.LoadAssetAtPath<Material>(matPath);
Texture2D tex = AssetDatabase.LoadAssetAtPath<Texture2D>(texPath);

mat.SetTexture("_MainTex", tex);
EditorUtility.SetDirty(mat);
AssetDatabase.SaveAssets();
return $"Assigned {tex.name} to material";
\`\`\`

## Assign Material to GameObject

\`\`\`csharp
using UnityEditor;

string matPath = "Assets/Materials/MyMaterial.mat";
Material mat = AssetDatabase.LoadAssetAtPath<Material>(matPath);

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

Renderer renderer = selected.GetComponent<Renderer>();
if (renderer == null)
{
    return "Selected object has no Renderer";
}

renderer.sharedMaterial = mat;
EditorUtility.SetDirty(selected);
return $"Assigned {mat.name} to {selected.name}";
\`\`\`

## Enable/Disable Material Keywords

\`\`\`csharp
using UnityEditor;

string matPath = "Assets/Materials/MyMaterial.mat";
Material mat = AssetDatabase.LoadAssetAtPath<Material>(matPath);

mat.EnableKeyword("_EMISSION");
mat.globalIlluminationFlags = MaterialGlobalIlluminationFlags.RealtimeEmissive;

EditorUtility.SetDirty(mat);
AssetDatabase.SaveAssets();
return "Emission enabled on material";
\`\`\`

## Find All Materials Using a Shader

\`\`\`csharp
using UnityEditor;

string shaderName = "Standard";
string[] guids = AssetDatabase.FindAssets("t:Material");
List<string> matchingMaterials = new List<string>();

foreach (string guid in guids)
{
    string path = AssetDatabase.GUIDToAssetPath(guid);
    Material mat = AssetDatabase.LoadAssetAtPath<Material>(path);
    if (mat != null && mat.shader != null && mat.shader.name == shaderName)
    {
        matchingMaterials.Add(path);
    }
}
return $"Found {matchingMaterials.Count} materials using {shaderName}";
\`\`\`

## Duplicate Material

\`\`\`csharp
using UnityEditor;

string sourcePath = "Assets/Materials/MyMaterial.mat";
string destPath = "Assets/Materials/MyMaterial_Copy.mat";

Material source = AssetDatabase.LoadAssetAtPath<Material>(sourcePath);
Material copy = new Material(source);
AssetDatabase.CreateAsset(copy, destPath);
AssetDatabase.SaveAssets();
return $"Material duplicated to {destPath}";
\`\`\`
`,
      'examples/prefab-operations.md': `# Prefab Operations

Code examples for Prefab operations using \`execute-dynamic-code\`.

## Create a Prefab from GameObject

\`\`\`csharp
using UnityEditor;

GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
cube.name = "MyCube";
string path = "Assets/Prefabs/MyCube.prefab";
PrefabUtility.SaveAsPrefabAsset(cube, path);
Object.DestroyImmediate(cube);
return $"Prefab created at {path}";
\`\`\`

## Instantiate a Prefab

\`\`\`csharp
using UnityEditor;

string prefabPath = "Assets/Prefabs/MyCube.prefab";
GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(prefabPath);
if (prefab == null)
{
    return $"Prefab not found at {prefabPath}";
}

GameObject instance = (GameObject)PrefabUtility.InstantiatePrefab(prefab);
instance.transform.position = new Vector3(0, 1, 0);
return $"Instantiated {instance.name}";
\`\`\`

## Add Component to Prefab

\`\`\`csharp
using UnityEditor;

string prefabPath = "Assets/Prefabs/MyCube.prefab";
GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(prefabPath);
string assetPath = AssetDatabase.GetAssetPath(prefab);

using (PrefabUtility.EditPrefabContentsScope scope = new PrefabUtility.EditPrefabContentsScope(assetPath))
{
    GameObject root = scope.prefabContentsRoot;
    if (root.GetComponent<Rigidbody>() == null)
    {
        root.AddComponent<Rigidbody>();
    }
}
return "Added Rigidbody to prefab";
\`\`\`

## Modify Prefab Properties

\`\`\`csharp
using UnityEditor;

string prefabPath = "Assets/Prefabs/MyCube.prefab";
GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(prefabPath);

using (PrefabUtility.EditPrefabContentsScope scope = new PrefabUtility.EditPrefabContentsScope(prefabPath))
{
    GameObject root = scope.prefabContentsRoot;
    root.transform.localScale = new Vector3(2, 2, 2);

    MeshRenderer renderer = root.GetComponent<MeshRenderer>();
    if (renderer != null)
    {
        renderer.sharedMaterial.color = Color.red;
    }
}
return "Modified prefab properties";
\`\`\`

## Find All Prefab Instances in Scene

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

string prefabPath = "Assets/Prefabs/MyCube.prefab";
GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(prefabPath);
if (prefab == null)
{
    return $"Prefab not found at {prefabPath}";
}

List<GameObject> instances = new List<GameObject>();

foreach (GameObject obj in Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None))
{
    if (PrefabUtility.GetCorrespondingObjectFromSource(obj) == prefab)
    {
        instances.Add(obj);
    }
}
return $"Found {instances.Count} instances of {prefab.name}";
\`\`\`

## Apply Prefab Overrides

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

if (!PrefabUtility.IsPartOfPrefabInstance(selected))
{
    return "Selected object is not a prefab instance";
}

PrefabUtility.ApplyPrefabInstance(selected, InteractionMode.UserAction);
return $"Applied overrides from {selected.name} to prefab";
\`\`\`
`,
      'examples/scene-operations.md': `# Scene Operations

Code examples for Scene and Hierarchy operations using \`execute-dynamic-code\`.

## Create GameObject

\`\`\`csharp
GameObject obj = new GameObject("MyObject");
obj.transform.position = new Vector3(0, 1, 0);
return $"Created {obj.name}";
\`\`\`

## Create Primitive

\`\`\`csharp
GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
cube.name = "MyCube";
cube.transform.position = new Vector3(2, 0, 0);
return $"Created {cube.name}";
\`\`\`

## Add Component to GameObject

\`\`\`csharp
GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

Rigidbody rb = selected.AddComponent<Rigidbody>();
rb.mass = 2f;
rb.useGravity = true;
return $"Added Rigidbody to {selected.name}";
\`\`\`

## Find GameObject by Name

\`\`\`csharp
GameObject obj = GameObject.Find("Player");
if (obj == null)
{
    return "GameObject 'Player' not found";
}
return $"Found: {obj.name} at {obj.transform.position}";
\`\`\`

## Find GameObjects by Tag

\`\`\`csharp
GameObject[] enemies = GameObject.FindGameObjectsWithTag("Enemy");
return $"Found {enemies.Length} GameObjects with tag 'Enemy'";
\`\`\`

## Set Parent

\`\`\`csharp
GameObject child = GameObject.Find("Child");
GameObject parent = GameObject.Find("Parent");

if (child == null || parent == null)
{
    return "Child or Parent not found";
}

child.transform.SetParent(parent.transform);
return $"Set {child.name}'s parent to {parent.name}";
\`\`\`

## Get All Children

\`\`\`csharp
GameObject parent = Selection.activeGameObject;
if (parent == null)
{
    return "No GameObject selected";
}

List<string> children = new List<string>();
foreach (Transform child in parent.transform)
{
    children.Add(child.name);
}
return $"Children: {string.Join(", ", children)}";
\`\`\`

## Wire Component References

\`\`\`csharp
using UnityEditor;

GameObject player = GameObject.Find("Player");
GameObject target = GameObject.Find("Target");

if (player == null || target == null)
{
    return "Player or Target not found";
}

MonoBehaviour script = player.GetComponent("PlayerController") as MonoBehaviour;
if (script == null)
{
    return "PlayerController not found on Player";
}

SerializedObject serializedScript = new SerializedObject(script);
SerializedProperty targetProp = serializedScript.FindProperty("target");

if (targetProp != null)
{
    targetProp.objectReferenceValue = target.transform;
    serializedScript.ApplyModifiedProperties();
    return "Target reference wired";
}
return "Property 'target' not found";
\`\`\`

## Load Scene (Editor)

\`\`\`csharp
using UnityEditor.SceneManagement;

string scenePath = "Assets/Scenes/MainMenu.unity";
EditorSceneManager.OpenScene(scenePath, OpenSceneMode.Single);
return $"Loaded scene: {scenePath}";
\`\`\`

## Save Current Scene

\`\`\`csharp
using UnityEditor.SceneManagement;

UnityEngine.SceneManagement.Scene scene = EditorSceneManager.GetActiveScene();
EditorSceneManager.SaveScene(scene);
return $"Saved scene: {scene.name}";
\`\`\`

## Create New Scene

\`\`\`csharp
using UnityEditor.SceneManagement;

UnityEngine.SceneManagement.Scene newScene = EditorSceneManager.NewScene(NewSceneSetup.DefaultGameObjects, NewSceneMode.Single);
return $"Created new scene: {newScene.name}";
\`\`\`

## Get All Root GameObjects in Scene

\`\`\`csharp
UnityEngine.SceneManagement.Scene scene = UnityEngine.SceneManagement.SceneManager.GetActiveScene();
GameObject[] roots = scene.GetRootGameObjects();

List<string> names = new List<string>();
foreach (GameObject root in roots)
{
    names.Add(root.name);
}
return $"Root objects: {string.Join(", ", names)}";
\`\`\`

## Destroy GameObject

\`\`\`csharp
GameObject obj = GameObject.Find("OldObject");
if (obj == null)
{
    return "GameObject not found";
}

Object.DestroyImmediate(obj);
return "GameObject destroyed";
\`\`\`

## Duplicate GameObject

\`\`\`csharp
GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

GameObject copy = Object.Instantiate(selected);
copy.name = selected.name + "_Copy";
copy.transform.position = selected.transform.position + Vector3.right * 2;
return $"Created duplicate: {copy.name}";
\`\`\`

## Set Active/Inactive

\`\`\`csharp
GameObject obj = GameObject.Find("MyObject");
if (obj == null)
{
    return "GameObject not found";
}

obj.SetActive(!obj.activeSelf);
return $"{obj.name} is now {(obj.activeSelf ? "active" : "inactive")}";
\`\`\`

## Modify Transform

\`\`\`csharp
GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

selected.transform.position = new Vector3(0, 5, 0);
selected.transform.rotation = Quaternion.Euler(0, 45, 0);
selected.transform.localScale = new Vector3(2, 2, 2);
return "Transform modified";
\`\`\`
`,
      'examples/scriptableobject.md': `# ScriptableObject Operations

Code examples for ScriptableObject operations using \`execute-dynamic-code\`.

## Create ScriptableObject Instance

\`\`\`csharp
using UnityEditor;

ScriptableObject so = ScriptableObject.CreateInstance<ScriptableObject>();
string path = "Assets/Data/MyData.asset";
AssetDatabase.CreateAsset(so, path);
AssetDatabase.SaveAssets();
return $"ScriptableObject created at {path}";
\`\`\`

## Create Custom ScriptableObject

\`\`\`csharp
using UnityEditor;

ScriptableObject so = ScriptableObject.CreateInstance("MyCustomSO");
if (so == null)
{
    return "Type 'MyCustomSO' not found. Ensure the class exists.";
}

string path = "Assets/Data/MyCustomData.asset";
AssetDatabase.CreateAsset(so, path);
AssetDatabase.SaveAssets();
return $"Created {so.GetType().Name} at {path}";
\`\`\`

## Modify ScriptableObject with SerializedObject

\`\`\`csharp
using UnityEditor;

string path = "Assets/Data/MyData.asset";
ScriptableObject so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);

if (so == null)
{
    return $"Asset not found at {path}";
}

SerializedObject serializedObj = new SerializedObject(so);
SerializedProperty prop = serializedObj.FindProperty("myField");

if (prop != null)
{
    prop.stringValue = "New Value";
    serializedObj.ApplyModifiedProperties();
    EditorUtility.SetDirty(so);
    AssetDatabase.SaveAssets();
    return "Property updated";
}
return "Property 'myField' not found";
\`\`\`

## Set Int/Float/Bool Properties

\`\`\`csharp
using UnityEditor;

string path = "Assets/Data/GameSettings.asset";
ScriptableObject so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);

SerializedObject serializedObj = new SerializedObject(so);

SerializedProperty intProp = serializedObj.FindProperty("maxHealth");
if (intProp != null) intProp.intValue = 100;

SerializedProperty floatProp = serializedObj.FindProperty("moveSpeed");
if (floatProp != null) floatProp.floatValue = 5.5f;

SerializedProperty boolProp = serializedObj.FindProperty("isEnabled");
if (boolProp != null) boolProp.boolValue = true;

serializedObj.ApplyModifiedProperties();
EditorUtility.SetDirty(so);
AssetDatabase.SaveAssets();
return "Properties updated";
\`\`\`

## Set Reference Properties

\`\`\`csharp
using UnityEditor;

string soPath = "Assets/Data/CharacterData.asset";
string prefabPath = "Assets/Prefabs/Player.prefab";

ScriptableObject so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(soPath);
GameObject prefab = AssetDatabase.LoadAssetAtPath<GameObject>(prefabPath);

if (so == null)
{
    return $"ScriptableObject not found at {soPath}";
}
if (prefab == null)
{
    return $"Prefab not found at {prefabPath}";
}

SerializedObject serializedObj = new SerializedObject(so);
SerializedProperty prop = serializedObj.FindProperty("playerPrefab");

if (prop != null)
{
    prop.objectReferenceValue = prefab;
    serializedObj.ApplyModifiedProperties();
    EditorUtility.SetDirty(so);
    AssetDatabase.SaveAssets();
    return "Reference set successfully";
}
return "Property not found";
\`\`\`

## Set Array/List Properties

\`\`\`csharp
using UnityEditor;

string path = "Assets/Data/ItemDatabase.asset";
ScriptableObject so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);

if (so == null)
{
    return $"Asset not found at {path}";
}

SerializedObject serializedObj = new SerializedObject(so);
SerializedProperty arrayProp = serializedObj.FindProperty("items");

if (arrayProp != null && arrayProp.isArray)
{
    arrayProp.ClearArray();
    arrayProp.InsertArrayElementAtIndex(0);
    arrayProp.GetArrayElementAtIndex(0).stringValue = "Sword";
    arrayProp.InsertArrayElementAtIndex(1);
    arrayProp.GetArrayElementAtIndex(1).stringValue = "Shield";

    serializedObj.ApplyModifiedProperties();
    EditorUtility.SetDirty(so);
    AssetDatabase.SaveAssets();
    return "Array updated with 2 items";
}
return "Array property not found";
\`\`\`

## Find All ScriptableObjects of Type

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

string typeName = "GameSettings";
string[] guids = AssetDatabase.FindAssets($"t:{typeName}");
List<string> paths = new List<string>();

foreach (string guid in guids)
{
    paths.Add(AssetDatabase.GUIDToAssetPath(guid));
}
return $"Found {paths.Count} {typeName} assets";
\`\`\`

## Duplicate ScriptableObject

\`\`\`csharp
using UnityEditor;

string sourcePath = "Assets/Data/Template.asset";
string destPath = "Assets/Data/NewInstance.asset";

ScriptableObject source = AssetDatabase.LoadAssetAtPath<ScriptableObject>(sourcePath);
if (source == null)
{
    return $"Source asset not found at {sourcePath}";
}

ScriptableObject copy = Object.Instantiate(source);
AssetDatabase.CreateAsset(copy, destPath);
AssetDatabase.SaveAssets();
return $"Duplicated to {destPath}";
\`\`\`

## List All Properties of ScriptableObject

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

string path = "Assets/Data/MyData.asset";
ScriptableObject so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);

if (so == null)
{
    return $"Asset not found at {path}";
}

SerializedObject serializedObj = new SerializedObject(so);
SerializedProperty prop = serializedObj.GetIterator();

List<string> properties = new List<string>();
while (prop.NextVisible(true))
{
    properties.Add($"{prop.name} ({prop.propertyType})");
}
return string.Join(", ", properties);
\`\`\`
`,
      'examples/selection-operations.md': `# Selection Operations

Code examples for Selection operations using \`execute-dynamic-code\`.

## Get Selected GameObjects

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

GameObject[] selected = Selection.gameObjects;
if (selected.Length == 0)
{
    return "No GameObjects selected";
}

List<string> names = new List<string>();
foreach (GameObject obj in selected)
{
    names.Add(obj.name);
}
return $"Selected: {string.Join(", ", names)}";
\`\`\`

## Get Active (Last Selected) GameObject

\`\`\`csharp
using UnityEditor;

GameObject active = Selection.activeGameObject;
if (active == null)
{
    return "No active GameObject";
}
return $"Active: {active.name}";
\`\`\`

## Set Selection Programmatically

\`\`\`csharp
using UnityEditor;

GameObject obj = GameObject.Find("Player");
if (obj == null)
{
    return "GameObject 'Player' not found";
}

Selection.activeGameObject = obj;
return $"Selected {obj.name}";
\`\`\`

## Select Multiple GameObjects

\`\`\`csharp
using UnityEditor;

GameObject[] enemies = GameObject.FindGameObjectsWithTag("Enemy");
if (enemies.Length == 0)
{
    return "No enemies found";
}

Selection.objects = enemies;
return $"Selected {enemies.Length} enemies";
\`\`\`

## Get Top-Level Transforms Only

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

Transform[] transforms = Selection.GetTransforms(SelectionMode.TopLevel);
if (transforms.Length == 0)
{
    return "No transforms selected";
}

List<string> names = new List<string>();
foreach (Transform t in transforms)
{
    names.Add(t.name);
}
return $"Top-level: {string.Join(", ", names)}";
\`\`\`

## Get Deep Selection (Including Children)

\`\`\`csharp
using UnityEditor;

Transform[] transforms = Selection.GetTransforms(SelectionMode.Deep);
if (transforms.Length == 0)
{
    return "No transforms selected";
}

return $"Deep selection count: {transforms.Length}";
\`\`\`

## Get Editable Objects Only

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

Transform[] transforms = Selection.GetTransforms(SelectionMode.Editable);
if (transforms.Length == 0)
{
    return "No editable transforms selected";
}

List<string> names = new List<string>();
foreach (Transform t in transforms)
{
    names.Add(t.name);
}
return $"Editable: {string.Join(", ", names)}";
\`\`\`

## Get Selected Assets

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

Object[] selectedAssets = Selection.GetFiltered<Object>(SelectionMode.Assets);
if (selectedAssets.Length == 0)
{
    return "No assets selected";
}

List<string> paths = new List<string>();
foreach (Object asset in selectedAssets)
{
    paths.Add(AssetDatabase.GetAssetPath(asset));
}
return $"Assets: {string.Join(", ", paths)}";
\`\`\`

## Get Selected Asset GUIDs

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

string[] guids = Selection.assetGUIDs;
if (guids.Length == 0)
{
    return "No assets selected";
}

List<string> paths = new List<string>();
foreach (string guid in guids)
{
    paths.Add(AssetDatabase.GUIDToAssetPath(guid));
}
return $"Selected assets: {string.Join(", ", paths)}";
\`\`\`

## Select All Children of Selected Object

\`\`\`csharp
using UnityEditor;
using UnityEngine;
using System.Collections.Generic;

GameObject parent = Selection.activeGameObject;
if (parent == null)
{
    return "No GameObject selected";
}

List<GameObject> children = new List<GameObject>();
foreach (Transform child in parent.GetComponentsInChildren<Transform>())
{
    if (child != parent.transform)
    {
        children.Add(child.gameObject);
    }
}

if (children.Count == 0)
{
    return "No children found";
}

Selection.objects = children.ToArray();
return $"Selected {children.Count} children";
\`\`\`

## Filter Selection by Component

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

GameObject[] selected = Selection.gameObjects;
List<GameObject> withRigidbody = new List<GameObject>();

foreach (GameObject obj in selected)
{
    if (obj.GetComponent<Rigidbody>() != null)
    {
        withRigidbody.Add(obj);
    }
}

if (withRigidbody.Count == 0)
{
    return "No objects with Rigidbody in selection";
}

Selection.objects = withRigidbody.ToArray();
return $"Filtered to {withRigidbody.Count} objects with Rigidbody";
\`\`\`

## Check if Object is Selected

\`\`\`csharp
using UnityEditor;

GameObject player = GameObject.Find("Player");
if (player == null)
{
    return "Player not found";
}

bool isSelected = Selection.Contains(player);
return $"Player is {(isSelected ? "" : "not ")}selected";
\`\`\`

## Clear Selection

\`\`\`csharp
using UnityEditor;

Selection.activeObject = null;
return "Selection cleared";
\`\`\`

## Select Objects by Layer

\`\`\`csharp
using UnityEditor;
using System.Collections.Generic;

int layer = LayerMask.NameToLayer("UI");
GameObject[] allObjects = Object.FindObjectsByType<GameObject>(FindObjectsSortMode.None);
List<GameObject> layerObjects = new List<GameObject>();

foreach (GameObject obj in allObjects)
{
    if (obj.layer == layer)
    {
        layerObjects.Add(obj);
    }
}

if (layerObjects.Count == 0)
{
    return "No objects found on UI layer";
}

Selection.objects = layerObjects.ToArray();
return $"Selected {layerObjects.Count} objects on UI layer";
\`\`\`

## Ping Object in Hierarchy/Project

\`\`\`csharp
using UnityEditor;

GameObject obj = GameObject.Find("Player");
if (obj == null)
{
    return "Player not found";
}

EditorGUIUtility.PingObject(obj);
return $"Pinged {obj.name} in Hierarchy";
\`\`\`

## Focus on Selected Object in Scene View

\`\`\`csharp
using UnityEditor;

if (Selection.activeGameObject == null)
{
    return "No GameObject selected";
}

SceneView.FrameLastActiveSceneView();
return "Focused on selected object";
\`\`\`

`,
      'examples/undo-operations.md': `# Undo Operations

Code examples for Undo-supported operations using \`execute-dynamic-code\`.

## Record Property Change (Undo.RecordObject)

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

Undo.RecordObject(selected.transform, "Move Object");
selected.transform.position = new Vector3(0, 5, 0);
return $"Moved {selected.name} (Undo available)";
\`\`\`

## Record Multiple Objects

\`\`\`csharp
using UnityEditor;

GameObject[] selectedObjects = Selection.gameObjects;
if (selectedObjects.Length == 0)
{
    return "No GameObjects selected";
}

Object[] transforms = new Object[selectedObjects.Length];
for (int i = 0; i < selectedObjects.Length; i++)
{
    transforms[i] = selectedObjects[i].transform;
}

Undo.RecordObjects(transforms, "Move Multiple Objects");
foreach (GameObject obj in selectedObjects)
{
    obj.transform.position += Vector3.up * 2;
}
return $"Moved {selectedObjects.Length} objects (Undo available)";
\`\`\`

## Complete Object Undo (For Complex Changes)

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

Undo.RegisterCompleteObjectUndo(selected, "Complete Object Change");
selected.name = "RenamedObject";
selected.layer = LayerMask.NameToLayer("Default");
selected.tag = "Untagged";
return $"Modified object completely (Undo available)";
\`\`\`

## Add Component with Undo

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

Rigidbody rb = Undo.AddComponent<Rigidbody>(selected);
rb.mass = 2f;
rb.useGravity = true;
return $"Added Rigidbody to {selected.name} (Undo available)";
\`\`\`

## Set Parent with Undo

\`\`\`csharp
using UnityEditor;

GameObject child = GameObject.Find("Child");
GameObject parent = GameObject.Find("Parent");

if (child == null || parent == null)
{
    return "Child or Parent not found";
}

Undo.SetTransformParent(child.transform, parent.transform, "Set Parent");
return $"Set {child.name}'s parent to {parent.name} (Undo available)";
\`\`\`

## Create GameObject with Undo

\`\`\`csharp
using UnityEditor;

GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
cube.name = "UndoableCube";
cube.transform.position = new Vector3(0, 1, 0);
Undo.RegisterCreatedObjectUndo(cube, "Create Cube");
return $"Created {cube.name} (Undo available)";
\`\`\`

## Destroy GameObject with Undo

\`\`\`csharp
using UnityEditor;

GameObject obj = GameObject.Find("ObjectToDelete");
if (obj == null)
{
    return "GameObject not found";
}

Undo.DestroyObjectImmediate(obj);
return "GameObject destroyed (Undo available)";
\`\`\`

## Named Undo Group

\`\`\`csharp
using UnityEditor;

GameObject selected = Selection.activeGameObject;
if (selected == null)
{
    return "No GameObject selected";
}

Undo.SetCurrentGroupName("Complex Transform Operation");

Undo.RecordObject(selected.transform, "");
selected.transform.position = Vector3.zero;
selected.transform.rotation = Quaternion.identity;
selected.transform.localScale = Vector3.one;

return "Reset transform (Single undo step)";
\`\`\`

## Collapse Multiple Operations into One Undo

\`\`\`csharp
using UnityEditor;

int undoGroup = Undo.GetCurrentGroup();
Undo.SetCurrentGroupName("Batch Operation");

GameObject cube1 = GameObject.CreatePrimitive(PrimitiveType.Cube);
cube1.name = "Cube1";
Undo.RegisterCreatedObjectUndo(cube1, "");

GameObject cube2 = GameObject.CreatePrimitive(PrimitiveType.Cube);
cube2.name = "Cube2";
cube2.transform.position = Vector3.right * 2;
Undo.RegisterCreatedObjectUndo(cube2, "");

GameObject cube3 = GameObject.CreatePrimitive(PrimitiveType.Cube);
cube3.name = "Cube3";
cube3.transform.position = Vector3.right * 4;
Undo.RegisterCreatedObjectUndo(cube3, "");

Undo.CollapseUndoOperations(undoGroup);
return "Created 3 cubes (Single undo step)";
\`\`\`

## Modify ScriptableObject with Undo

\`\`\`csharp
using UnityEditor;

string path = "Assets/Data/GameSettings.asset";
ScriptableObject so = AssetDatabase.LoadAssetAtPath<ScriptableObject>(path);
if (so == null)
{
    return $"Asset not found at {path}";
}

Undo.RecordObject(so, "Modify Settings");
SerializedObject serializedObj = new SerializedObject(so);
SerializedProperty prop = serializedObj.FindProperty("maxHealth");
if (prop != null)
{
    prop.intValue = 200;
    serializedObj.ApplyModifiedProperties();
}
return "Modified ScriptableObject (Undo available)";
\`\`\`

## Modify Material with Undo

\`\`\`csharp
using UnityEditor;

string path = "Assets/Materials/MyMaterial.mat";
Material mat = AssetDatabase.LoadAssetAtPath<Material>(path);
if (mat == null)
{
    return $"Material not found at {path}";
}

Undo.RecordObject(mat, "Change Material Color");
mat.color = Color.red;
return "Changed material color (Undo available)";
\`\`\`

`,
    },
  },
  {
    name: 'uloop-execute-menu-item',
    dirName: 'uloop-execute-menu-item',
    content: executeMenuItemSkill,
  },
  {
    name: 'uloop-find-game-objects',
    dirName: 'uloop-find-game-objects',
    content: findGameObjectsSkill,
  },
  {
    name: 'uloop-focus-window',
    dirName: 'uloop-focus-window',
    content: focusWindowSkill,
  },
  {
    name: 'uloop-get-hierarchy',
    dirName: 'uloop-get-hierarchy',
    content: getHierarchySkill,
  },
  {
    name: 'uloop-get-logs',
    dirName: 'uloop-get-logs',
    content: getLogsSkill,
  },
  {
    name: 'uloop-get-menu-items',
    dirName: 'uloop-get-menu-items',
    content: getMenuItemsSkill,
  },
  {
    name: 'uloop-get-provider-details',
    dirName: 'uloop-get-provider-details',
    content: getProviderDetailsSkill,
  },
  {
    name: 'uloop-run-tests',
    dirName: 'uloop-run-tests',
    content: runTestsSkill,
  },
  {
    name: 'uloop-unity-search',
    dirName: 'uloop-unity-search',
    content: unitySearchSkill,
  },
];

export function getBundledSkillByName(name: string): BundledSkill | undefined {
  return BUNDLED_SKILLS.find((skill) => skill.name === name);
}
